<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="viewport" content="width = device-width">
		<meta name="viewport" content="initial-scale = 1.0, user-scalable = no">
		<title>CSE 469 Computer and Network Forensics Class Project</title>
		<link href="/rsc/Styles.css" rel="stylesheet" type="text/css" />
	</head>

	<body>

		<div class="Banner">

		</div>

		<div class="AddressConversionTool">
		Please enter a command in the following format.
		<br>
			-L | -P | -C [-B [-s bytes]] [-l address] [-p address] [-c address -k sectors -r sectors -t tables -f sectors] 
		<br>
			<form>
				Address Conversion Tool: <input type="text" name="addressConversion" id="addressConversionInput">
				<input type="button" onclick="addressConvert()" value="Submit" id="addressConversion">
			</form>

				<textarea class="FormElement" id="addressConversionOutput" name="addressConversionOutput" cols="40" rows="4"></textarea>

			<script type="text/javascript">
				function addressConvert() {
				var AddressConversionText = document.getElementById('addressConversionInput').value;
				var AddressCommand = new Array();
				var curToken = "";
				var numCommands = -1;
				var isWhiteSpace = new RegExp(/^\s$/);
				var isEqualSign = new RegExp(/^=+$/);
				//document.getElementById("addressConversionOutput").value = "\Length is: " + AddressConversionText.length;

				for(var i=0;i<AddressConversionText.length;i++)
				{
					if(i == (AddressConversionText.length-1))
					{
						//document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\n2nd Statement";
						curToken += AddressConversionText.charAt(i);
						numCommands++;
						AddressCommand[numCommands] = curToken;
						//document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\n"+ AddressCommand[numCommands];
						curToken = "";
					}
					else if(!isWhiteSpace.test(AddressConversionText.charAt(i)) && !isEqualSign.test(AddressConversionText.charAt(i)))
					{
						//document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\n1st Statement";
						curToken += AddressConversionText.charAt(i);
						//document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\n" + AddressConversionText.charAt(i);
					}
					else
					{
						//document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\n3rd Statement";
						numCommands++;
						AddressCommand[numCommands] = curToken;
						//document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\n"+ AddressCommand[numCommands];
						curToken ="";
					}
				}

				var Logical=false, Physical=false, Cluster=false, ByteAddress=false, partitionStart=0, byteAddress=-1, 
					sectorSize=512,	logicalKnown=-1, physicalKnown=-1, clusterKnown=-1, clusterSize=-1, reserved=-1,
					fatTables=-1, fatLength =-1, result=0;

					//document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\nnumCommands = "+ numCommands;


				
				//Displays the AddressCommand array
				////////////////////////
				for(var i=0; i<numCommands+1; i++)
				{
					document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\nAddressCommand Array = ";
					document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + AddressCommand[i] + ", ";
				}

				for(var i=0; i<numCommands; i++)
				{
					//alert(AddressCommand[i] + (AddressCommand[i] == "--physical-known"));
					if((AddressCommand[i] == "-L") || (AddressCommand[i] == "--logical"))
					{
						Logical = true;
					}
					else if((AddressCommand[i] == "-P") || (AddressCommand[i] == "--physical"))
					{
						Physical = true;
					}
					else if((AddressCommand[i] == "-C") || (AddressCommand[i] == "--cluster"))
					{
						Cluster = true;
					}
					else if((AddressCommand[i] == "-b") || (AddressCommand[i] == "--partition-start"))
					{
					//document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\nAddressCommand[" + i + "] = partitionStart = " + AddressCommand[i+1];
						partitionStart=parseInt(AddressCommand[i+1]);
						i++;
					}
					else if((AddressCommand[i] == "-B") || (AddressCommand[i] == "--byte-address"))
					{
						ByteAddress = true;
					}
					else if((AddressCommand[i] == "-s") || (AddressCommand[i] == "--sector-size"))
					{
						sectorSize=parseInt(AddressCommand[i+1]);
						i++;
					}
					else if((AddressCommand[i] == "-l") || (AddressCommand[i] == "--logical-known"))
					{
						logicalKnown=parseInt(AddressCommand[i+1]);
						i++;
					}
					else if((AddressCommand[i] == "-p") || (AddressCommand[i] == "--physical-known"))
					{
					//document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\nAddressCommand[" + i + "] = Physical Address = " + AddressCommand[i+1];
						physicalKnown=parseInt(AddressCommand[i+1]);
						i++;
					}
					else if((AddressCommand[i] == "-c") || (AddressCommand[i] == "--cluster-known"))
					{
						clusterKnown= parseInt(AddressCommand[i+1]);
						i++;
					}
					else if((AddressCommand[i] == "-k") || (AddressCommand[i] == "--cluster-size"))
					{
						clusterSize= parseInt(AddressCommand[i+1]);
						i++;
					}
					else if((AddressCommand[i] == "-r") || (AddressCommand[i] == "--reserved"))
					{
						reserved= parseInt(AddressCommand[i+1]);
						i++;
					}
					else if((AddressCommand[i] == "-t") || (AddressCommand[i] == "--fat-tables"))
					{
						fatTables= parseInt(AddressCommand[i+1]); 
						i++;
					}
					else if((AddressCommand[i] == "-f") || (AddressCommand[i] == "--fat-length"))
					{
						fatLength = parseInt(AddressCommand[i+1]);
						i++;
					}
					else 
					{
						//do nothing
					}
				}

				if(Logical == true)
				{
					if (logicalKnown != -1)
					{
						result = logicalKnown;
					}
					else if (physicalKnown != -1)
					{
						result = physicalKnown-partitionStart;
					}
					else if (clusterKnown != -1)
					{
						result = ((clusterKnown - 2) * clusterSize) + reserved + (fatTables * fatLength);
					}

					if (ByteAddress==true)
					{
						result = result * sectorSize;
						document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\nLogical Address = " + result + " bytes";//logic to handle logical address
					}
					else
					{
						document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\nLogical Address = " + result + "(sectors)";//logic to handle logical address
					}
				}
				if(Physical == true)
				{
					if (physicalKnown != -1)
					{
						result = physicalKnown;
					}
					else if (logicalKnown != -1)
					{
						result = logicalKnown + partitionStart;
					}
					else if (clusterKnown != -1)
					{
						//document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\npartitionStart = " + partitionStart + "\nclusterKnown = " + clusterKnown + "\nclusterSize = " + clusterSize + "\nreserved = " + reserved + "\nfatTables = " + fatTables + "\nfatLength = " + fatLength;
						result = partitionStart +((clusterKnown - 2) * clusterSize) + reserved + (fatTables * fatLength);
					}

					if (ByteAddress==true)
					{
						result = result * sectorSize;
						document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\nLogical Address = " + result + " bytes";//logic to handle logical address

					}
					else
					{
						document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\nPhysical Address = " + result + "(sectors)";//logic to handle logical address
					}
				}
				if(Cluster == true)
				{
					if (clusterKnown != -1)
					{
						result = clusterKnown;
					}
					else if (logicalKnown != -1)
					{
						result = (logicalKnown - fatTables * fatLength - reserved)/clusterSize + 2;
					}
					else if (physicalKnown != -1)
					{
						result = (physicalKnown - partitionStart - fatTables * fatLength - reserved)/clusterSize + 2;
					}

					if (ByteAddress==true)
					{
						result = result * sectorSize * clusterSize;
						document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\nCluster Address = " + result + " bytes";//logic to handle logical address

					}
					else
					{
						document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\nCluster Address = " + result + "(sectors)";//logic to handle logical address
					}
				}

				//output conversion
				//document.getElementById("addressConversionOutput").value = "1st line";
				//document.getElementById("addressConversionOutput").value = document.getElementById("addressConversionOutput").value + "\nappending sample output";

			}
			</script>
		</div>

		<div class="MacConversionTool">
		<br>
		Please enter a command in the following format.
		<br>
		-T | -D [-h hex value]
		<form>
				Mac Conversion Tool: <input type="text" name="macConversion" id="macConversion">
				<input type="button" onclick="macConvertInput()" value="Submit">
		</form>
		<textarea class="FormElement" id="macConversionHexOutput" name="macConversionHexOutput" cols="40" rows="4"></textarea>
		<br>
		<br>
		-T | -D
		<form>
				Mac Conversion Tool: <input type="text" name="macConversionFile" id="macConversionFile">
				<input type="file" id="macFileInput" />
				<input type="button" onclick="macConvertFile()" value="Submit">
		</form>
		<textarea class="FormElement" id="macConversionFileOutput" name="macConversionFileOutput" cols="40" rows="4"></textarea>
		<br>
		<br>
		<script type="text/javascript">
				function macConvertInput()
				{
				//document.getElementById("macConversionHexOutput").value = document.getElementById("macConversionHexOutput").value + "\nTesting Button";
				var MacConversionText = document.getElementById('macConversion').value;
				var macCommand = new Array();
				var curToken = "";
				var numCommands = -1;
				var white = new RegExp(/^\s$/);

				for(var i=0;i<MacConversionText.length;i++)
				{
					if(i == (MacConversionText.length-1))
					{
						curToken += MacConversionText.charAt(i);
						numCommands++;
						macCommand[numCommands] = curToken;
						curToken="";
					}
					else if(!white.test(MacConversionText.charAt(i)))
					{
						curToken += MacConversionText.charAt(i);
					}
					else
					{
						numCommands++;
						macCommand[numCommands] = curToken;
						curToken="";
					}
				}
				
				var timeConvert=false, dateConvert=false, macHexValue;
				for(var i=0; i<numCommands; i++)
				{
					if(macCommand[i] == "-T")
					{
						timeConvert = true;
					}
					else if(macCommand[i] == "-D")
					{
						dateConvert = true;
					}
					else if(macCommand[i] == "-h")
					{
						macHexValue = macCommand[i+1];
						i++;
					}
					else 
					{
						//do nothing
					}
				}

				
				//Displays the macCommand array
				///////////////////////////////////
				for(var i=0; i<numCommands+1; i++)
				{
					document.getElementById("macConversionHexOutput").value = document.getElementById("macConversionHexOutput").value + "\nmacCommand Array = ";
					document.getElementById("macConversionHexOutput").value = document.getElementById("macConversionHexOutput").value + macCommand[i] + ", ";
				}
				
				var year=0, month=0, day=0;
				
				
				if(timeConvert == true)
				{
					//logic to handle time conversion
					
					document.getElementById("macConversionHexOutput").value = document.getElementById("macConversionHexOutput").value + "\nTime: ";

				}
				if(dateConvert == true)
				{
					//logic to handle date conversion
					
					//year = parseInt(macHexValue.charAt(2)) * 8 + Math.floor(parseInt(macHexValue.charAt(3)/2));
					//document.getElementById("macConversionHexOutput").value = document.getElementById("macConversionHexOutput").value + "Test: " + macHexValue);
					
					document.getElementById("macConversionHexOutput").value = document.getElementById("macConversionHexOutput").value + "\nDate: ";
					
					document.getElementById("macConversionHexOutput").value = document.getElementById("macConversionHexOutput").value + "Year: " + year;
					
				}
			}
		</script>
		
		<script type="text/javascript">
		function macConvertFile() {  
					// obtain input element through DOM 
  
					var file = document.getElementById('macFileInput').files[0];
					if(file){
						getAsText(file);
					}
				}

			function getAsText(readFile) {
        
				var reader = new FileReader();
				
				// Read file into memory as UTF-16      
				reader.readAsBinaryString(readFile);
  
				// Handle progress, success, and errors
				reader.onprogress = updateProgress;
				reader.onload = loaded;
				reader.onerror = errorHandler;
			}

			function updateProgress(evt) {
				if (evt.lengthComputable) {
					// evt.loaded and evt.total are ProgressEvent properties
					var loaded = (evt.loaded / evt.total);
					if (loaded < 1) {
						// Increase the prog bar length
						// style.width = (loaded * 200) + "px";
					}
				}
			}

			function loaded(evt) {  
				
				// Obtain the read file data    
				var fileString = evt.target.result;
				
				var hex = "";
                for (var i = 0; i < fileString.length; i++) {
                    var byteStr = fileString.charCodeAt(i).toString(16);
                    if (byteStr.length < 2) {
                        byteStr = "0" + byteStr;
                    }
                    hex += " " + byteStr;
					
                }
				
				//filedump as hex
                alert(MBRPartState + "\n"+ MBRBeginPartHead + "\n" + MBRBeginPartSector + "\n"+ hex);
				
				// filedump as binary
				//alert(fileString);
			}
			
			function errorHandler(evt) {
				if(evt.target.error.name == "NotReadableError") {
					// The file could not be read
				}
			}
				
		</script>
		</div>

		<div class="RawImageTool">
			Raw Image Tool
			<br>
			Image File: 
			<input type="file" id="ImageFile" name="files[]" multiple />
			<input type="button" onclick="ImageFile()" value="Submit">
			<output id="list"></output>

			<script type="text/javascript">
				function ImageFile() {  
					// obtain input element through DOM 
  
					var file = document.getElementById('ImageFile').files[0];
					if(file){
						getAsText(file);
					}
				}

			function getAsText(readFile) {
        
				var reader = new FileReader();
				
				// Read file into memory as UTF-16      
				reader.readAsBinaryString(readFile);
  
				// Handle progress, success, and errors
				reader.onprogress = updateProgress;
				reader.onload = loaded;
				reader.onerror = errorHandler;
			}

			function updateProgress(evt) {
				if (evt.lengthComputable) {
					// evt.loaded and evt.total are ProgressEvent properties
					var loaded = (evt.loaded / evt.total);
					if (loaded < 1) {
						// Increase the prog bar length
						// style.width = (loaded * 200) + "px";
					}
				}
			}

			function loaded(evt) {  
				var MBRPartState; //0x00 | current state of partition 00=inactive, 80=active | 1 byte
				var MBRBeginPartHead; //0x01 | beginning of partition head | 1 byte
				var MBRBeginPartSector; //0x02 | beginning of partition cylinder/sector | 1 word
				var MBRPartType; //0x04 | type of partition | 1 byte
				var MBREndPartHead; //0x05 | end of partition head | 1 byte
				var MBREndPartSector; //0x06 | end of partition cylinder sector | 1 word
				var MBRNumSectorsToFirstPart; //0x08 | number of sectors between the MBR and the 1st sector in the partition | 1 double word
				var MBRNumSectorsInPart; //0x0C | number of sectors in the partition | 1 double word
				
				// Obtain the read file data    
				var fileString = evt.target.result;
				
				var hex = "";
                for (var i = 0; i < fileString.length; i++) {
                    var byteStr = fileString.charCodeAt(i).toString(16);
                    if (byteStr.length < 2) {
                        byteStr = "0" + byteStr;
                    }
                    hex += " " + byteStr;
					
					if(i==2)
					{
						MBRBeginPartSector = byteStr;
					}
					else if(i==3)
					{
						var temp = MBRBeginPartSector;
						MBRBeginPartSector = byteStr + temp;
						//this may not work needs testing
						MBRBeginPartSector = MBRBeginPartSector.toString(10);
					}
					else if(i==4)
					{
						alert(byteStr);
						if(byteStr == "01")
						{
							MBRPartType = "01 DOS 12-bit FAT";
						}
						else if(byteStr == "04")
						{
							MBRPartType = "04 DOS 16-bit FAT less than 32mb";
						}
						else if(byteStr == "05")
						{
							MBRPartType = "05 Extended Partition";
						}
						else if(byteStr == "06")
						{
							MBRPartType = "06 DOS 16-bit FAT greater than 32mb";
						}
						else if(byteStr == "07")
						{
							MBRPartType = "07 NTFS";
						}
						else if(byteStr == "08")
						{
							MBRPartType = "08 AIX bootable partition";
						}
						else if(byteStr == "09")
						{
							MBRPartType = "09 AIX data partition";
						}
						else if(byteStr == "0B")
						{
							MBRPartType = "0B DOS 32-bit FAT";
						}
						else if(byteStr == "0C")
						{
							MBRPartType = "0C DOS 32-bit FAT interrupt 13 support";
						}
						else if(byteStr == "17")
						{
							MBRPartType = "17 Hidden NTFS partition";
						}
						else if(byteStr == "1B")
						{
							MBRPartType = "1B Hidden FAT32 partition";
						}
						else if(byteStr == "1E")
						{
							MBRPartType = "1E Hidden VFAT partition";
						}
						else if(byteStr == "3C")
						{
							MBRPartType = "3C Partition Magic recovery partition";
						}
						else if(byteStr == "66" || byteStr == "67" || byteStr == "68" || byteStr == "69")
						{
							MBRPartType = "66-69 Novell partitions";
						}
						else if(byteStr == "81")
						{
							MBRPartType = "81 Linux";
						}
						else if(byteStr == "82")
						{
							MBRPartType = "82 Linux swap partition";
						}
						else if(byteStr == "83")
						{
							MBRPartType = "83 Linux native file systems";
						}
						else if(byteStr == "86")
						{
							MBRPartType = "86 FAT16 volume/stripe set";
						}
						else if(byteStr == "87")
						{
							MBRPartType = "87 High Performance File System";
						}
						else if(byteStr == "A5")
						{
							MBRPartType = "A5 FreeBSD and BSD/386";
						}
						else if(byteStr == "A6")
						{
							MBRPartType = "A6 OpenBSD";
						}
						else if(byteStr == "A9")
						{
							MBRPartType = "A9 NetBSD";
						}
						else if(byteStr == "C7")
						{
							MBRPartType = "C7 Corrupted NTFS";
						}
						else if(byteStr == "EB")
						{
							MBRPartType = "EB BeOS";
						}
						else
						{
							MBRPartType = "not known type";
						}
						
					}
					else if(i==6)
					{
						MBREndPartSector = byteStr;
					}
					else if(i==7)
					{
						var temp = MBREndPartSector;
						MBREndPartSector = byteStr + temp;
						//this may not work needs testing
						MBREndPartSector = MBREndPartSector.toString(10);
					}
					else
					{
						//do nothing
					}
                }
				
				//filedump as hex
                alert(MBRPartType + "\n" + parseInt(MBRBeginPartSector, 16) + "\n" + (parseInt(MBREndPartSector, 16)-parseInt(MBRBeginPartSector, 16)) + "\n"+ hex);
				
				// filedump as binary
				//alert(fileString);
			}
			
			function errorHandler(evt) {
				if(evt.target.error.name == "NotReadableError") {
					// The file could not be read
				}
			}
				
			</script>
			

<script type="text/javascript">
  function readSingleFile(evt) {
					/*
					MBR
					0x04, 0x02, 0x06 minus 0x02
					
					//0x02 | beginning of partition cylinder/sector | 1 word
					//0x04 | type of partition | 1 byte
					//0x06 | end of partition cylinder/sector | 1 word
					
					~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					
					VBR
					Reserved area: Start sector: 0	Ending sector: (0x0014-0x0015 -1) sector	Size: (0x0014-0x0015)	sectors
					Sectors per cluster: (0x0013) sectors
					FAT area: Start sector: (0x0014-0x0015) Ending sector: (0x0014-0x0015 + (0x0016)*(0x0036-0x0039 or 0x0022-0x0023))
					# of FATs: (0x0016)
					The size of each FAT: (0x0036-0x0039 or 0x0022-0x0023) sectors
					The first sector of cluster 2: (0x0014-0x0015 + (0x0016)*(0x0036-0x0039 or 0x0022-0x0023)) + (0x0017-0x0018) sectors
					
					0-2 assembly instruction to jump to boot code
					3-10 OEM Name in ASCII
					11-12 bytes per sector
					->>13 sectors per cluster | Sectors per cluster: # sectors
					->>14-15 size in sectors of the reserved area	| start sector: 0 Ending Sector: (14-15 - 1) Size (14-15) sectors
					->>16-16 number of FATs | # of FATs: #
					17-18 maximum number of files in the root directory
					19-20 16-bit value of number of sectors in FS (FAT32:0)
					21-21 media type
					22-23 16-bit size in sectors of each FAT (FAT32:0)
					24-25 sectors per track
					26-27 number of heads
					28-31 number of sectors before the start of partition
					32-35 number of sectors in file system
					->>36-39 32-bit size in sectors of each FAT | The size of each FAT: # sectors
					67-70 volume serial number
					71-81 volume name
					82-89 file system type label
					510-511 signature value
					*/
</script>

			<br>
			<div class="ButtonField">
				
			</div>
		</div>
			<div class="OutputField">
			</div>

		</div>

	</body>

</html>